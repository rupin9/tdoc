[[chiselbasics]]
== Chisel Basics

chisel-tutorial directory structure는 아래의 <<fig:chisel-tutorial-structure>>와 같다.
그림에서 보는 바와 같이, src디렉토리 아래에 main과 test에 존재하며, 
examples, problems, solutions 디렉토리가 각각 pair로 있다.

[[fig:chisel-tutorial-structure]]
.Chisel-tutorial directory structure
[ditaa,float="center"]
----
.[root directory]
├── doc
│   ├── style
│   └── tutorial
│       └── figs
├── project
└── src
    ├── main
    │   └── scala
    │       ├── examples
    │       ├── hello
    │       ├── problems
    │       └── solutions
    └── test
        ├── resources
        └── scala
            ├── examples
            ├── problems
            ├── solutions
            └── utils
----

=== Implementation of the 1st Chisel Code

GCD.scala 예제를 실행을 통하여, chisel-tutorial 의 전반적인 활용에 대해서 간단히 알아본다.

.GDC.scala
[source,%nowrap,scala,linenums]
----
package examples
import chisel3._

class GCD extends Module {
  val io = IO(new Bundle {
    val a     = Input(UInt(16.W))
    val b     = Input(UInt(16.W))
    val load  = Input(Bool())
    val out   = Output(UInt(16.W))
    val valid = Output(Bool())
  })
  val x = Reg(UInt())
  val y = Reg(UInt())

  when (io.load) {
    x := io.a; y := io.b
  } .otherwise {
    when (x > y) {
      x := x - y
    } .elsewhen (x <= y) {
      y := y - x
    }
  }

  io.out := x
  io.valid := y === 0.U
}
----

[.rfont]#import chisel3._# 선언은 chisel3 라이브러리를 사용하겠다는 선언이다.
그 이후에 HW 모듈을 정의하는 class GCD extends Module { ... } 가 나온다.
Module은 chisel3 라이브러리에서 제공하는 추상 클래스이다.
즉, GCD 클래스는 Module 클래스를 상속받아, HW 모듈을 정의한다.
HW 모듈은 입출력 포트와 내부 레지스터, 그리고 동작을 정의한다.

입출력 포트는 val io = IO(new Bundle{...}) 라는 이름의 Bundle 객체로 정의된다.
Bundle 객체는 여러 개의 포트를 묶어서 하나의 객체로 만들 수 있다.
입출력 포트는 Input, Output, 그리고 Bool, UInt 등의 데이터 타입으로 정의된다.

[NOTE]
====
IO 객체의 정의는 chisel3 라이브러리의 내부 API로서 다음과 같이 설명되어 있다.
```scala
// IO object must wrap the datatype used to set the io field of any Module.
// i.e. All concrete modules must have defined io in this form:
[lazy] val io[: io type] = IO(...[: io type])
```
====

내부 레지스터는 Reg 객체로 정의된다. 필요에 따라서, RegInit 객체로 초기값을 지정할 수도 있다.
또한, RegNext 객체로 1사이클의 지연후에 값을 저장할 수도 있다.
동작은 when, .elsewhen, .otherwise 등의 제어문으로 정의되는데, 
이러한 동작은 HW적으로는 멀티플렉서(mux)로 구현된다.
제어문에서 발생하는 레지스터 할당은 := 연산자로 이루어지는데, 
HW적으로는 always @ (posedge clk) 를 사용하여, non-blocking assignment로 구현된다.

[NOTE]
====
Reg 객체의 정의는 chisel3 라이브러리의 내부 API이며, 특히, width가 지정되지 않은 경우에는 
FIRRTL compiler에 의해 유추 (inferred) 된다는 점이 중요하다. 몇 가지 예를 들면 다음과 같다.

* Reg(): Utility for constructing hardware registers
```scala
// Reg 객체의 width 지정 예
val r0 = Reg(UInt())    // width is inferred
val r1 = Reg(UInt(8.W)) // width is set to 8

// Reg(Bundle) 객체의 width 지정 예
class MyBundle {
  val unknown = UInt()
  val known   = UInt(8.W)
}
val r4 = Reg(new MyBundle)
// Width of r4.unknown is inferred
// Width of r4.known is set to 8
```
* RegNext(): Utility for constructing one-cycle delayed versions of signals
```scala
// Reg 객체의 width 지정 예
val foo = Reg(UInt(4.W))         // width is 4
val bar = RegNext(foo)           // width is unset till be inferred by the firrtl compiler.

// 만약, 명시적으로 width를 지정하고자 한다면, 다음과 같이 chiselTypeOf() 함수를 사용한다.
val foo = Reg(UInt(4.W))         // width is 4
val bar = Reg(chiselTypeOf(foo)) // width is 4
bar := foo

// Reg(Bundle) 객체의 width 지정 예 (width set of aggregate is inferred, when not specified)
class MyBundle extends Bundle {
  val x = UInt(4.W)
}
val foo = Wire(new MyBundle)     // the width of foo.x is 4
val bar = RegNext(foo)           // the width of bar.x is 4
```
* RegInit(): Utility for constructing hardware registers with an initialization value.
```scala
// 1. Literal Bits (값) initializer: width will be set to match
val r1 = RegInit(1.U)       // width will be inferred to be 1
val r2 = RegInit(1.U(8.W))  // width is set to 8

// 2. Non-Literal Element (원소) initializer - width will be inferred
val x = Wire(UInt())
val y = Wire(UInt(8.W))
val r1 = RegInit(x) // width will be inferred
val r2 = RegInit(y) // width is set to 8

// 3. Aggregate initializer - width will be set to match the aggregate
class MyBundle extends Bundle {
  val unknown = UInt()
  val known   = UInt(8.W)
}
val w1 = Reg(new MyBundle)
val w2 = RegInit(w1)
// Width of w2.unknown is inferred
// Width of w2.known is set to 8
```
====

마지막으로, io.out 과 io.valid 포트에 값을 할당한다.
io.out 포트에는 x 레지스터의 값을 할당하고, io.valid 포트에는 y 레지스터가 0인지 여부를 할당한다.
참고로, x, y 레지스터는 각각 16비트의 unsigned integer로 chisel에 의해 암묵적으로 유추된다.

=== Running the 1st Chisel Code

구현된 GCD 모듈을 실행하기 위해서는, chisel tester 라이브러리와 firrtl을 활용한다.
`src/test/scala/examples/` 디렉토리에 GCDTests.scala 파일을 두고, test 코드를 작성한다(튜토리얼에 이미 준비되어 있다).

[[src:gcd-tests-scala]]
.GCDTests.scala
[source,%nowrap,scala,linenums]
----
package examples

import chisel3.iotesters.{ChiselFlatSpec, Driver, PeekPokeTester}

class GCDTests(c: GCD) extends PeekPokeTester(c) {
  val inputs = List( (48, 32), (7, 3), (100, 10) )
  val outputs = List( 16, 1, 10)

  var i = 0
  do {
    poke(c.io.a, inputs(i)._1)
    poke(c.io.b, inputs(i)._2)

    poke(c.io.load, 1)
    step(1)
    poke(c.io.load, 0)

    var ready = false

    do {
      ready = peek(c.io.valid) == 1
      step(1)
    } while (t < 100 && ! ready)

    expect(c.io.out, outputs(i))
    i += 1
  } while (t < 100 && i < 3)

  if (t >= 100) fail
}

class GCDTester extends ChiselFlatSpec {
  behavior of "GCD"

  backends foreach {backend =>
    it should s"test the basic gcd circuit" in {
      Driver(() => new GCD, backend)((c) => new GCDTests(c)) should be (true)
    }
  }
}
----

<<src:gcd-tests-scala>>를 참조하면, 크게 [ModuleName][.bfont]#Tests# 클래스와 [ModuleName][.bfont]#Tester# 클래스
2개로 구현된다. Tests 클래스에는 PeekPokeTester를 상속받아, 실제 테스트 벡터를 적용하고, 결과를 검증하는 코드를 작성한다.
Tester 클래스에는 ChiselFlatSpec을 상속받아, 테스트를 실행하는 코드를 작성한다.
Tester 클래스의 it should ... in { ... } 블록 안에서, Driver 함수를 호출하여, 테스트를 실행한다.
Driver 함수는 첫 번째 인자로 test 대상 (여기서는 GCD) 이 되는 Module[T <: MultiIOModule]을 받고,
두 번째 인자로 PeekPokeTester[T] 받아서, 동작하게 된다. Driver 함수는 테스트가 성공하면 true, 실패하면 false를 반환한다.

실행은 프롬프트에서 다음과 같이 sbt 명령어로 실행한다.

[[src:run-gcd-bash]]
.Running GCD
[source,%nowrap,bash,linenums]
----
$ sbt -v "test:runMain examples.Launcher GCD"
... 중략 ...
[info] running examples.Launcher GCD
Starting tutorial GCD
[info] [0.011] Elaborating design...
[info] [3.175] Done elaborating.
Computed transform order in: 1468.1 ms
Total FIRRTL Compile Time: 2826.8 ms
file loaded in 0.189982079 seconds, 21 symbols, 16 statements
[info] [0.002] SEED 175674601 n 29 cycles in 0.053474 seconds 542.32 Hz
[info] [0.019] RAN 24 CYCLES PASSED
Tutorials passing: 1
[success] Total time: 132 s (0:02:12.0), completed Sep 2, 2025, 2:00:21 AM
----

위의 실행 결과에서 보는 바와 같이, 테스트 벡터의 입력 List( (48, 32), (7, 3), (100, 10) )에 대한
출력 결과가 성공하였다. 실행 스크립트인 `sbt -v "test:runMain examples.Launcher GCD"`을 좀 더 살펴보면,
test:runMain 은 sbt의 기본 명령어로서, test 스코프에 있는 (src/test/scala 디렉토리에 있는 파일들) 
함수 호출을 위해서는 examples 패키지의 Launcher 객체의 main 함수를 호출한다는 의미입니다.
<<src:launcher-scala>>를 참조하면, Launcher 객체의 main 함수는 TutorialRunner 객체의 apply 함수를 호출합니다.
TutorialRunner 객체의 apply 함수는 첫 번째 인자로 섹션 이름 (여기서는 examples), 
두 번째 인자로 튜토리얼 맵 (여기서는 examples 맵), 세 번째 인자로 커맨드 라인 인자 (여기서는 GCD)를 받습니다.

[[src:launcher-scala]]
.Launcher.scala and TutorialRunner.scala
[source,%nowrap,scala,linenums]
----
// @chisel-tutorial/src/test/scala/examples/Launcher.scala
package examples

import chisel3.iotesters.{Driver, TesterOptionsManager}
import utils.TutorialRunner

object Launcher {
  val examples = Map(
      ...
      "GCD" -> { (manager: TesterOptionsManager) =>
        Driver.execute(() => new GCD, manager) {
          (c) => new GCDTests(c)
        }
      },
      ...
  )
  def main(args: Array[String]): Unit = {
    TutorialRunner("examples", examples, args)
  }
}

// @chisel-tutorial/src/test/scala/utils/TutorialRunner.scala
package utils

import scala.collection.mutable.ArrayBuffer
import chisel3.iotesters._

object OptionsCopy {
  def apply(t: TesterOptionsManager): TesterOptionsManager = {
    new TesterOptionsManager {
      testerOptions = t.testerOptions.copy()
      interpreterOptions = t.interpreterOptions.copy()
      chiselOptions = t.chiselOptions.copy()
      firrtlOptions = t.firrtlOptions.copy()
      treadleOptions = t.treadleOptions.copy()
    }
  }
}

object TutorialRunner {
  def apply(section: String, 
            tutorialMap: Map[String, TesterOptionsManager => Boolean], 
            args: Array[String]): Unit = {

    ...
    testOptionsManager.setTargetDirName(s"test_run_dir/$section/$testName")
    ...

    if(successful > 0) {
      println(s"Tutorials passing: $successful")
    }
    if(errors.nonEmpty) {
      println(s"Errors: ${errors.length}: in the following tutorials")
      System.exit(1)
    }
  }
}
----

sbt에서 test:runMain을 실행했을 때 src/main/example 디렉토리의 GCD 객체도 함께 컴파일되됩니다.
이것은 sbt의 자동 의존성 관리에 의해서 이루어 집니다.

Scope analysis and dependency check:::
  스코프 분석: sbt는 test:runMain 명령어를 보고 Test 스코프 내의 코드를 실행해야 한다는 것을 파악합니다.
  의존성 파악: sbt는 test 스코프의 클래스(examples.Launcher)가 compile 스코프에 있는 GCD와 같은 다른 클래스에 의존하고 있다는 것을 자동으로 분석합니다.

Run compile chain:::
  sbt는 runMain을 실행하기 전에 test 스코프의 모든 의존성을 컴파일합니다.
  이때 test 스코프는 compile 스코프의 코드를 포함하므로, sbt는 src/main/example 디렉토리에 있는 GCD와 같은 compile 스코프의 코드를 먼저 컴파일합니다.
  test 스코프의 코드가 compile 스코프의 코드에 의존하므로, sbt는 compile 스코프가 먼저 컴파일되고 그 결과가 test 스코프에 사용될 수 있도록 보장합니다.

=== Generate Verilog and VCD

기본적으로 테스트 결과는 <<src:run-gcd-bash>> 에 보이는 것처럼 콘솔 화면에 보여주지만,
TutorialRunner는 빌드의 결과물인 .fir 파일과 .v 파일을 생성하여 test_run_dir에 저장합니다.
즉, Verilog 파일이 `test_run_dir/examples/GCD/GCD.v`에 생성되고, 같은 디렉토리에
GCD.fir`에 생성됩니다.

Verilog 파일과 더불어 VCD (Value Change Dump) 파일도 생성할 수 있는데, `--backend-name` 옵션을 사용하여, +
$ sbt -v "test:runMain examples.Launcher GCD --backend-name verilator" 명령어로 실행하면 됩니다. +
이 옵션은 TutorialRunner의 apply 함수에서 testOptionsManager.setBackendName(backend)로 전달되어 설정됩니다.
Verilator 백엔드를 사용하면, verilog파일을 c++로 변환하고 시뮬레이션을 실행하고, VCD 파일을 생성할 수 있습니다.

[[src:run-gcd-verilator-bash]]
.Running GCD with Verilator backend
[source,%nowrap,bash,linenums]
----
$ sbt -v "test:runMain examples.Launcher GCD --backend-name verilator"
[sbt_options] declare -a sbt_options=()
... 중략 ...
[info] running examples.Launcher GCD --backend-name verilator
Starting tutorial GCD
[info] [0.004] Elaborating design...
[info] [0.179] Done elaborating.
... 중략 ...
sim start on Note9 at Sun Sep  7 07:23:57 2025
STARTING test_run_dir/examples/GCD/VGCD
[info] [0.002] SEED 1757197413301
Enabling waves..
Exit Code: 0
[info] [0.100] RAN 24 CYCLES PASSED
Tutorials passing: 1
[success] Total time: 29 s, completed Sep 7, 2025, 7:23:57 AM
----

위의 실행 결과로 부터 생성되는, VCD 파일이 `test_run_dir/examples/GCD/VGCD.vcd`에 생성됩니다.

.test_run_dir/examples/GCD after running with Verilator backend
image::test_run_dir_examples_GCD.png[]

GTKWave와 같은 뷰어로, VCD열어서, 다음과 같이 시뮬레이션 결과를 확인할 수 있습니다.

.GCD waveform
image::test_run_dir_examples_GCD_waveform.png[]

