== Introduction


Chisel (Constructing Hardware in a Scala Embedded Language) 을 사용하여 
하드웨어를 설계하는 방법을 배우는 문서입니다. 이 문서는 Chisel의 기본 개념과 사용법을 소개하며, 
다양한 예제를 통해 실습할 수 있도록 구성되어 있습니다.

스터디를 위해서, https://github.com/chipsalliance/chisel/ 를 참고하지만, 세부적으로 다음을 참고합니다.

* https://mybinder.org/v2/gh/freechipsproject/chisel-bootcamp/master
Jupyter 노트북을 통해 Chisel을 실습할 수 있는 환경을 제공합니다.
* https://github.com/ucb-bar/chisel-tutorial
여러가지 다양한 예제를 제공하는 Chisel 튜토리얼입니다. 다음의 위키 페이지 내용을 참고합니다.
** https://github.com/ucb-bar/chisel-tutorial/wiki
* https://www.chisel-lang.org/docs/cookbooks
여기에서, 자주 사용되는 설계 패턴등을 확인하고, 배울 수 있습니다.
(((bootcamp, cookbook)))

=== Chisel 설치하기


jdk 설치하기

scala 설치하기

* The retirement of an instruction.
* A trap, as defined in <<trap-defn>>.
* Any other event defined by an extension to constitute forward
progress.

[NOTE]
====
The term hart was introduced in the work on Lithe cite:[lithe-pan-hotpar09] and cite:[lithe-pan-pldi10] to provide a term to
represent an abstract execution resource as opposed to a software thread
programming abstraction.

The important distinction between a hardware thread (hart) and a
====

=== Base Instruction-Length Encoding

The base RISC-V ISA has fixed-length 32-bit instructions that must be
naturally aligned on 32-bit boundaries. However, the standard RISC-V
encoding scheme is designed to support ISA extensions with
variable-length instructions, where each instruction can be any number
of 16-bit instruction _parcels_ in length and parcels are naturally
aligned on 16-bit boundaries. The standard compressed ISA extension
described in (compressed) reduces code size by
providing compressed 16-bit instructions and relaxes the alignment
constraints to allow all instructions (16 bit and 32 bit) to be aligned
on any 16-bit boundary to improve code density.

We use the term IALIGN (measured in bits) to refer to the
instruction-address alignment constraint the implementation enforces.
IALIGN is 32 bits in the base ISA, but some ISA extensions, including
the compressed ISA extension, relax IALIGN to 16 bits. IALIGN may not
take on any value other than 16 or 32.
(((ILEN)))

We use the term ILEN (measured in bits) to refer to the maximum
instruction length supported by an implementation, and which is always a
multiple of IALIGN. For implementations supporting only a base
instruction set, ILEN is 32 bits. Implementations supporting longer
instructions have larger values of ILEN.

All the 32-bit
instructions in the base ISA have their lowest two bits set to `11`. The
optional compressed 16-bit instruction-set extensions have their lowest
two bits equal to `00`, `01`, or `10`.

[NOTE]
====
Given the code size and energy savings of a compressed format, we wanted
to build in support for a compressed format to the ISA encoding scheme
rather than adding this as an afterthought, but to allow simpler
implementations we didn't want to make the compressed format mandatory.
We also wanted to optionally allow longer instructions to support
experimentation and larger instruction-set extensions. Although our
encoding convention required a tighter encoding of the core RISC-V ISA,
this has several beneficial effects.
(((IMAFD)))

An implementation of the standard IMAFD ISA need only hold the
most-significant 30 bits in instruction caches (a 6.25% saving). On
instruction cache refills, any instructions encountered with either low
bit clear should be recoded into illegal 30-bit instructions before
storing in the cache to preserve illegal-instruction exception behavior.

Perhaps more importantly, by condensing our base ISA into a subset of
the 32-bit instruction word, we leave more space available for
non-standard and custom extensions. In particular, the base RV32I ISA
uses less than 1/8 of the encoding space in the 32-bit instruction word.
An implementation that does not require support
for the standard compressed instruction extension can map 3 additional non-conforming
30-bit instruction spaces into the 32-bit fixed-width format, while preserving
support for standard &#8805;32-bit instruction-set
extensions.
====

Encodings with bits [15:0] all zeros are defined as illegal
instructions. These instructions are considered to be of minimal length:
16 bits if any 16-bit instruction-set extension is present, otherwise 32
bits. The encoding with bits [ILEN-1:0] all ones is also illegal; this
instruction is considered to be ILEN bits long.

[NOTE]
====
We consider it a feature that any length of instruction containing all
zero bits is not legal, as this quickly traps erroneous jumps into

Software can rely on a naturally aligned 32-bit word containing zero to
act as an illegal instruction on all RISC-V implementations, to be used
====
(((endian, little and big)))
RISC-V base ISAs have either little-endian or big-endian memory systems,
with the privileged architecture further defining bi-endian operation.
Instructions are stored in memory as a sequence of 16-bit little-endian
parcels, regardless of memory system endianness. Parcels forming one
instruction are stored at increasing halfword addresses, with the
lowest-addressed parcel holding the lowest-numbered bits in the
instruction specification.
(((bi-endian)))
(((endian, bi-)))

[NOTE]
====
We originally chose little-endian byte ordering for the RISC-V memory

Once we had decided to fix on a little-endian instruction encoding, this
naturally led to placing the length-encoding bits in the LSB positions
of the instruction format to avoid breaking up opcode fields.
====

[[trap-defn]]
=== Exceptions, Traps, and Interrupts

We use the term _exception_ to refer to an unusual condition occurring
at run time associated with an instruction in the current RISC-V hart.
(((exceptions)))
(((traps)))
(((interrupts)))


Contained Trap:::
  The trap is visible to, and handled by, software running inside the
Requested Trap:::
  The trap is a synchronous exception that is an explicit call to the
Invisible Trap:::
  The trap is handled transparently by the execution environment and

Fatal Trap:::
  The trap represents a fatal failure and causes the execution


<<trapcharacteristics>> shows the characteristics of each kind of trap.

[[trapcharacteristics]]
.Characteristics of traps
[%autowidth,float="center",align="center",cols="<,^,^,^,^",options="header",]
|===
| |Contained |Requested |Invisible |Fatal
|Execution terminates |No |No^1^|No |Yes
|Software is oblivious |No |No |Yes |Yes^2^|Handled by environment |No |Yes |Yes |Yes
|===

^1^ Termination may be requested +
^2^ Imprecise fatal traps might be observable by software

The EEI defines for each trap whether it is handled precisely, though
the recommendation is to maintain preciseness where possible. Contained

=== UNSPECIFIED Behaviors and Values
The architecture fully describes what implementations must do and any
constraints on what they may do. In cases where the architecture
intentionally does not constrain implementations, the term UNSPECIFIED is
explicitly used.
(((unspecified, behaviors)))
(((unspecified, values)))

The term UNSPECIFIED refers to a behavior or value that is intentionally
unconstrained. The definition of these behaviors or values is open to
