[[chiselmoduleinstantiation]]
== Chisel Module Instantiation

Chisel에서 모듈을 인스턴스화는 verilog에서 module을 인스턴스화하는 것과 동일합니다.
다음과 같이 Module 클래스를 상속받는 서브클래스를 정의 후에, instance를 생성할 때에는
Module(new ...) 생성자를 사용합니다.
```scala
class FuncBlock extends Module {
  val io = IO(new Bundle { ... }) 
  ...
}

...
val fb0 = Module(new FuncBlock())
```
Hierarchical module instantiation이 지원되어, 상위 모듈에서 하위 모듈의 인스턴스를 만들어
사용하게 됩니다. 관련하여, 다음의 4-bit full adder 구현 예제를 참조하시기 바랍니다.

[[fig:four-bit-full-adder]]
.4-bit Full Adder block diagram
image::4_Bit_Adder.jpg[]

[[src:four-bit-full-adder]]
.4-bit FullAdder.scala
[source,scala,%nowrap,linenums]
----
// A 4-bit adder with carry in and carry out
class Adder4 extends Module {
  val io = IO(new Bundle {
    val A    = Input(UInt(4.W))
    val B    = Input(UInt(4.W))
    val Cin  = Input(UInt(1.W))
    val Sum  = Output(UInt(4.W))
    val Cout = Output(UInt(1.W))
  })
  // Adder for bit 0
  val Adder0 = Module(new FullAdder())
  Adder0.io.a   := io.A(0)
  Adder0.io.b   := io.B(0)
  Adder0.io.cin := io.Cin
  val s0 = Adder0.io.sum
  // Adder for bit 1
  val Adder1 = Module(new FullAdder())
  Adder1.io.a   := io.A(1)
  Adder1.io.b   := io.B(1)
  Adder1.io.cin := Adder0.io.cout
  val s1 = Cat(Adder1.io.sum, s0)
  // Adder for bit 2
  val Adder2 = Module(new FullAdder())
  Adder2.io.a   := io.A(2)
  Adder2.io.b   := io.B(2)
  Adder2.io.cin := Adder1.io.cout
  val s2 = Cat(Adder2.io.sum, s1)
  // Adder for bit 3
  val Adder3 = Module(new FullAdder())
  Adder3.io.a   := io.A(3)
  Adder3.io.b   := io.B(3)
  Adder3.io.cin := Adder2.io.cout
  io.Sum  := Cat(Adder3.io.sum, s2).asUInt
  io.Cout := Adder3.io.cout
}
----

=== Vec class

Vec 클래스는 동일한 타입의 여러 개의 요소를 가지는 벡터를 표현합니다. 다음과 같이 선언할 수 있습니다.
위에서, <number of elements>는 벡터의 요소 개수를 지정하는 정수 값입니다.
<data type>은 벡터의 각 요소가 가지는 데이터 타입을 지정합니다.
```scala
// 기본형
val vec0 = Vec(Seq.fill( <number of elements> ) { <data type> })
// Unit 타입의 벡터 예제
val vec1 = Vec(Seq.fill(4) { UInt(8.W) })
// Reg 타입의 벡터 예제
val reg_vec32 = Reg(Vec(Seq.fill(32){ UInt() }))
// Vec 원소에 값 할당하기
vec1(0) := 10.U
vec1(1) := 20.U
...
// Indexing하기
val elem0 = vec1(0) // 첫 번째 원소 접근
val elem1 = vec1(1) // 두 번째 원소 접근
...
// VecInit 사용하기
val vec2 = VecInit(Seq.fill(4){ 0.U(8.W) }) // 4개의 8비트 UInt 요소를 가지는 Vec 생성
val vec2 = VecInit(Seq(1.U, 2.U, 3.U, 4.U)) // 4개의 요소를 가지는 Vec 생성
```
Module의 벡터화는 조금 다르게 설정해야 합니다. Module은 IO bundle로 Vec 타입을 사용할 수 있습니다.
```scala
val adder4 = Vec(Seq.fill(4){ Module(new FullAdder()).io })   
```
이와 같이 Module의 IO bundle을 Vec 타입으로 선언하는 이유는 쉽게 얘기해서, Module(...)는 Vec의 원소가 될 수 없기 때문입니다.
Vec는 Bool, UInt, SInt, Bundle 등 하드웨어 신호를 나타내는 데이터 타입만 원소로 가질 수 있습니다.
Vec는 FullAdder와 같은 모듈 전체를 원소로 가질 수 없습니다. Module(new FullAdder())는 이러한 신호 타입이 아니라, 그 신호들을 포함하는 상위 개념의 모듈 인스턴스입니다.
따라서, 위은 adder4에서는 Vec를 사용하여 여러 개의 동일한 모듈 인스턴스를 만들고, 
그 모듈들의 io 포트를 하나의 벡터로 묶습니다. 이 벡터는 다른 모듈과 연결하기 위한 '연결선들의 배열' 역할을 합니다.

=== Memories

Chisel에서, ROM (Read Only Memory) 은 VecInit을 이용하여 구현할 수 있습니다.
다음은 n개의 entry를 가지는 sine lookup table을 ROM으로 구성한 예입니다.

```scala
val Pi = math.Pi
def sinTable(amp: Double, n: Int) = {
  val times =
    (0 until n).map(i => (i*2*Pi)/(n.toDouble-1) - Pi)
  val inits =
    times.map(t => Math.round(amp * math.sin(t)).asSInt(32.W))
  VecInit(inits)
}
```

Read-Write 메모리는 기본적으로 2가지 경우로 나뉠 수 있습니다.

. SyncReadMem: Sequential/synchronous-read, sequential/synchronous-write
만약에, 동일한 클럭 엣지에서 같은 메모리 주소에 동기/순차 쓰기와 읽기를 동시에 수행하면, 
읽힌 데이터의 값은 보장이 되지 않습니다. 즉, 읽은 값은 undefined 입니다.
따라서, 동일한 클럭에서 같은 주소에 쓰기와 읽기 요청을 동시에 보내지 않도록 설계해야 합니다.

. Mem: combinational/asynchronous-read, sequential/synchronous-write
메모리 블록 자체는 데이터를 읽어온 후에도 그 값을 레지스터에 보관하는 기능을 갖고 있지 않습니다. 
다음 클럭 사이클까지 값을 유지해야 한다면 외부 로직을 추가해야 합니다.

SyncReadMem은 SRAM으로 합성되며, Mem은 register bank로 합성이 됩니다.
아래에 구현 예를 나열하였다. 그래고, 아래의 코드에서 SyncReadMem 대신 Mem을 사용하면 비동기읽기가 된다.

```scala
import chisel3._

// Read and write ports are separated.
class ReadWriteSmem extends Module {
  val width: Int = 32
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val write = Input(Bool())
    val addr = Input(UInt(10.W))
    val dataIn = Input(UInt(width.W))
    val dataOut = Output(UInt(width.W))
  })

  val mem = SyncReadMem(1024, UInt(width.W))
  // Create one write port and one read port
  mem.write(io.addr, io.dataIn)
  io.dataOut := mem.read(io.addr, io.enable)
}

// Read and write port can be shared when r/w is mutulally exclusive.
class RWSmem extends Module {
  val width: Int = 32
  val io = IO(new Bundle {
    val enable = Input(Bool())
    val write = Input(Bool())
    val addr = Input(UInt(10.W))
    val dataIn = Input(UInt(width.W))
    val dataOut = Output(UInt(width.W))
  })

  val mem = SyncReadMem(1024, UInt(width.W))
  io.dataOut := DontCare
  when(io.enable) {
    val rdwrPort = mem(io.addr)
    when (io.write) { rdwrPort := io.dataIn }
      .otherwise    { io.dataOut := rdwrPort }
  }

  // Another implementation using readWrite method
  // val mem = SyncReadMem(1024, UInt(width.W))
  // io.dataOut := mem.readWrite(io.addr, io.dataIn, io.enable, io.write)
}
```

=== Parameterized Module

Vec 클래스를 활용하여, 파라미터화된 모듈을 구현할 수 있습니다. <<parameterized-module>> 예제를 참조하시기 바랍니다.
`n` 비트 크기를 파라미터로 받아서, `n` 비트 크기의 덧셈을 수행하는 Adder 모듈을 이와 같이 구현할 수 있습니다.

[[src:parameterized-module]]
.Parameterized n-bit FullAdder module
[source,scala,%nowrap,linenums]
----
// A n-bit adder with carry in and carry out
class Adder(n: Int) extends Module {
  val io = IO(new Bundle {
    val A    = Input(UInt(n.W))
    val B    = Input(UInt(n.W))
    val Cin  = Input(UInt(1.W))
    val Sum  = Output(UInt(n.W))
    val Cout = Output(UInt(1.W))
  })
  // create a vector of FullAdders
  val FAs = Vec(Seq.fill(n){ Module(new FullAdder()).io })

  // define carry and sum wires
  val carry = Wire(Vec(n+1, UInt(1.W)))
  val sum   = Wire(Vec(n, UInt(1.W)))

  // first carry is the top level carry in
  carry(0) := io.Cin

  // wire up the ports of the full adders
  for(i <- 0 until n) {
    FAs(i).a   := io.A(i)
    FAs(i).b   := io.B(i)
    FAs(i).cin := carry(i)
    carry(i+1) := FAs(i).cout
    sum(i)     := FAs(i).sum
  }
  io.Sum  := sum.asUInt
  io.Cout := carry(n)
}
----

이 모듈의 인스턴스화는 다음과 같이 간단히 할 수 있습니다.
파라미터 `n`을 지정하면, 좀 더 명확하게 인스턴스화할 수 있습니다.
(이 경우는 아니지만, 파라미터가 여러개일 때에는, 파라미터 이름을 명시하는 것이 좋습니다.)
```scala
val adder8 = Module(new Adder(8))  // 8-bit adder
val adder16 = Module(new Adder(n=16)) // 16-bit adder
```

=== Builtin Primitive

Reg, Unit, Wire, IO, Module, Vec, Bundle, Mem 등은 chisel에서 제공하는 빌트인 프리미티브입니다.
이 외에도, chisel에서 제공하는 여러 가지 빌트인 프리미티브가 있습니다.
다음은 그 중에서 자주 사용되는 것들입니다.
```scala
// Shift Register
ShiftRegister(data: T, n: Int): T
// Mux
Mux(sel: Bool, a: T, b: T): T
// PriorityMux
PriorityMux(sel: Seq[Bool], in: Seq[T]): T
// Fill
Fill(n: Int, in: T): T
// Cat
Cat(in: T*): UInt
// Reverse
Reverse(in: T): T
```

