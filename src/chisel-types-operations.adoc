[[chiseltypesoperations]]
== Chisel Basics Types and Operations

chisel-tutorial directory structure는 아래의 <<fig:chisel-tutorial-structure>>와 같다.
그림에서 보는 바와 같이, src디렉토리 아래에 main과 test에 존재하며, 
examples, problems, solutions 디렉토리가 각각 pair로 있다.

=== Chisel Assignments and Re-assignments

Chisel에서 변수에 값 (value) 를 최초 값을 할당할 때에는 `=` 연산자를 사용합니다.
그 다음에 그 값에 대해서 값을 변경할 때에는 `:=` 연산자를 사용합니다. 즉, 재할당 연산자라고 할 수 있습니다.

디지털회로 노드 사이의 연결은 verilog에서는 한번 만 명시되어 동작하지만, chisel에서는 reassignment가 필요한
상황이 발생합니다. 그 이유는 chisel은 순차적으로 컴파일이 실행되므로, chisel 코드에서
어떤 변수는 연결신호의 값이 선언 시점에 unkown이었다가 나중에 known일 경우가 발생하므로, 
값을 재할당하는 코드가 필요합니다. <<fig:chisel-reassignment>>를 참조하면, `:=` 가 사용된 곳이
2군데 있습니다. 하나는 `io.sum` 이고, 다른 하나는 `io.cout` 입니다.
이는 io Bundle을 생성할 시점에, 해당 값들이 unknown이었기 때문에, 그 이후에 값을 재할당하는 코드가 필요하기 때문입니다.
Rule of thumb 은 만약 이미 그 값이 `=` 연산자로 할당된 값이라면, 그 이후에는 `:=` 연산자로 값을 재할당하는 것입니다.
그렇지 않은 경우에는 `=` 연산자로 값을 할당합니다.
만약, `=` 또는 `:=` 연산자를 잘못 사용하면, 컴파일 시점에 에러가 발생합니다.
<<fig:full-adder>>를 참조하면, Full Adder의 블록 다이어그램이 나와 있습니다.

[[src:full-adder-scala]]
.FullAdder.scala
[source,scala,%nowrap,linenums]
----
package examples

import chisel3._

class FullAdder extends Module {
  val io = IO(new Bundle {
    val a    = Input(UInt(1.W))
    val b    = Input(UInt(1.W))
    val cin  = Input(UInt(1.W))
    val sum  = Output(UInt(1.W))
    val cout = Output(UInt(1.W))
  })

  // Generate the sum
  val a_xor_b = io.a ^ io.b
  io.sum := a_xor_b ^ io.cin
  // Generate the carry
  val a_and_b = io.a & io.b
  val b_and_cin = io.b & io.cin
  val a_and_cin = io.a & io.cin
  io.cout := a_and_b | b_and_cin | a_and_cin
}
----

[[fig:full-adder]]
.Full_Adder block diagram
image::Full_Adder.jpg[]

=== UInt class

UInt 클래스는 unsigned integer를 표현하는 클래스입니다.
많은 경우에, chisel에서 연산은 UInt 클래스로 충분히 표현할 수 있습니다.
상수 값은 `n.U` 와 같이 표현하며, 여기서 n은 10진수 정수입니다.
연산이 적용될 때에는 다음과 같이 동일한 연산자가 사용되어야 합니다.
```scala
io.output := io.a + 1.U
```

기본적인 산술 연산과 논리연산이 다음과 같이 지원됩니다. 논리 연산의 결과는
Bool 클래스가 됩니다.
```scala
// arithmetic
+, -, *, /, %, ~, ^, &, |, 
// logical
===, =/=, >, <, >=, <=
```

Uint 클래스에서, bit extraction, bit selection, bit concatenation 등이 지원됩니다.
```scala
// bit extraction
val bit3 = io.input(3) // extract bit 3 (0-indexed)
// bit selection
val bits3to1 = io.input(3, 1) // extract bits 3 to 1
// bit concatenation
import chisel3.util._ // for Cat
val bitconcat = Cat(io.input1, io.input0) // concatenate two UInts   
```

UInt 연산을 수행하고 나면, 결과의 bit-width가 달라질 수 있습니다. Chisel은
자동으로 bit-width를 유추합니다. 다음의 예에서 보면, mult의 bit-width는 할당하지
않았지만, 이는 32비트가 됩니다.

```scala
// chisel
class HiLoMultiplier() extends Module {
  val io = IO(new Bundle {
    val A  = Input(UInt(16.W))
    val B  = Input(UInt(16.W))
    val Hi = Output(UInt(16.W))
    val Lo = Output(UInt(16.W))
  })
  val mult = io.A * io.B
  io.Lo := mult(15, 0)
  io.Hi := mult(31, 16)
}
```
```verilog
// verilog
module HiLoMultiplier(
    input [15:0] io_A,
    input [15:0] io_B,
    output[15:0] io_Hi,
    output[15:0] io_Lo);

  wire[15:0] T0;
  wire[31:0] mult; // Chisel infers this to be 32 bits
  wire[15:0] T1;

  assign io_Lo = T0;
  assign T0 = mult[4'hf:1'h0];
  assign mult = io_A * io_B;
  assign io_Hi = T1;
  assign T1 = mult[5'h1f:5'h10];
endmodule
```

다음 <<tab:bitwidth-uint>>에 연산을 수행 후, 유추되는 bit-width를 정리하였습니다.

[[tab:bitwidth-uint]]
.Bit-width of UInt operations 
[%autowidth]
|===
|Operation	|Result Bit Width

|Z = X - Y or Z = X -% Y	      |max(Width(X), Width(Y))
|Z = X -& Y	      |max(Width(X), Width(Y)) + 1
|Z = X + Y or Z = X +% Y	      |max(Width(X), Width(Y))
|Z = X +& Y	      |max(Width(X), Width(Y)) + 1
|Z = X & Y	      |max(Width(X), Width(Y))
|Z = X \| Y	      |max(Width(X), Width(Y))
|Z = X ^ Y	      |max(Width(X), Width(Y))
|Z = ~X	          |Width(X)
|Z = Mux(C, X, Y)	|max(Width(X), Width (Y))
|Z = X * Y	      |Width(X) + Width(Y)
|Z = X << n	      |Width(X) + maxNum(n)
|Z = X >> n	      |Width(X) - minNum(n)
|Z = Cat(X, Y)	  |Width(X) + Width(Y)
|Z = Fill(n, x)	  |Width(X) * maxNum(n)
|===

=== Bool class

Chisel에서 Bool 클래스는 logical 값을 표현하는 사용되며, _true_ 또는 _false_ 값을 가집니다.
주로, _when_ 구문에서 조건을 표현하는데 사용됩니다.
```scala
// Initialize Bool values
val true_value  = true.B
val false_value = false.B

// Logical operations
val change = io.a === io.b // change gets Bool type
when (change) {            // exec if change is true
  ...
} .otherwise {
  ...
}
```

=== Type Casting

Scala/chisel에서는 타입이 엄격하게 구분됩니다. 예를 들어, UInt 클래스와 Bool 클래스는 서로 다른 타입입니다.
따라서, UInt 클래스와 Bool 클래스 간의 연산은 허용되지 않습니다. 필요할 때에, 타입 캐스팅을 해야 합니다.

Bool -> UInt 타입 캐스팅을 할 때에는, asUInt 메서드를 사용합니다.
```scala
io.out := (in === 0.U).asUInt // UInt cast
```
UInt로 타입캐스팅할 때에, toUInt 메서드도 사용될 수 있습니다만, asUInt 메서드와 동작의 차이가 있습니다.
asUInt 메서드는 C코드에서 *(uint32_t *)ptr 와 같이, 메모리의 값을 그대로 읽어오는 것과 유사합니다.
즉, bit pattern을 그대로 UInt 값으로 해석하는 명시적 캐스팅입니다. 비트폭은 변동되지 않습니다.

반면에, toUInt 메서드는 다른 타입의 값을 UInt의 논리적 범위로 변환합니다.
다음의 예시코드를 보시면, SInt 클래스의 값을 UInt 클래스로 변환할 때에, 음수 값은 0으로 변환되는 것을 알 수 있습니다.
또한, toUInt 메서드는 변환 후 비트 폭이 조절될 수 있습니다.
```scala
// 양수 SInt 변환
val mySInt1 = 5.S(4.W) // 4비트 이진수로 0101
val myUInt1 = mySInt1.toUInt // myUInt1은 5.U (비트 너비는 3으로 조정)

// 음수 SInt 변환 (chisel 3.6 이상)
val mySInt2 = (-3).S(4.W)
val myUInt2 = mySInt2.toUInt // myUInt2는 0.U가 됩니다.
```

UInt -> Bool 타입 캐스팅을 할 때에는, asBool 메서드를 사용합니다.
```scala
val myUInt = Wire(UInt(1.W))
myUInt := 1.U
val myBool = myUInt.asBool() // myBool은 true가 됩니다.
```
이는 명시적인 타입캐스팅인데, 암묵적인 타입캐스팅도 지원합니다. 다음과 같이
1bit 이상의 UInt 클래스에 대해서도, toBool 메서드를 사용하여, Bool 타입으로 암묵적인 타입캐스팅이 가능합니다.
이는 값이 0이 아니면 true, 0이면 false가 됩니다.
```scala
val myUInt = Wire(5.U(3.W))
val myBool1 = myUInt.toBool() // 5는 0이 아니므로, myBool1은 true가 됩니다.
myUInt := 0.U
val myBool2 = myUInt.toBool() // 0은 0이므로, myBool2는 false가 됩니다.
```

[[tab:asBool-vs-toBool]]
.Comparision asBool and toBool
[%autowidth]
|===
|특징	|asBool |toBool

|동작          |명시적 비트 해석          |암묵적 0여부 확인
|적용 대상      |1비트 UInt만 가능	      |1비트 이상 UInt 모두 가능
|하드웨어 구현   |비트 값을 그대로 사용	    |`!= 0.U` 비교 로직 생성
|사용 시점	   |1비트 값을 논리 값으로 사용 |값이 0인지 아닌지 확인
|===

